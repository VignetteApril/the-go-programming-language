// 包级别的变量会一直在程序执行的过程中存在
// 相反的是local变量有着动态的生命周期
// 1、一个新的变量实例用声明语句被创建出来之后就一直存在直到它再也不会被引用的时候销毁
// 2、一个方法的【参数】也是一个loca变量，当方法被调用的时候会被创建一次


package main

import (
	"fmt"
)

func main() {
	// 在for这个语句中，变脸 t 每次循环都会重新创建一遍，同时 x y 也是一样
	for t := 0.0; t < cycles*2*math; t += res {
		x := math.Sin(t)
		y := math.Sin(t*freq + phase)
		imag.SetColorIndex(size+int(x*size + 0.5), size + int(y*size + 0.5), blackIndex)
	}
}

// 那么说go的垃圾回收机制是怎么做的？
// 基本概念：
// 1、每一个包级别的变量 or 方法中的local变量，都是被一个路径所引用的，如果这个路径不存在了
// 也就是意味着这个变量再也拿不到了，所以它也无法对后面的计算产生影响了
// 因为变量的生命周期其实被是否能被拿到所决定的，所以一个local变量可能会在一个loop之外继续存活
// 知道当前这个function return之后才被销毁

// 编译器可能会选择申请一个变量在 堆 或者 栈上
// 一般包级别的变量会在堆上申请空间
// local变量会在栈上申请空间
// Notice：在写go代码的时候，一定要注意不要将短声明周期变量的地址保存到包级别变量中，这种
// 做法会导致垃圾回收机制无法回收这个应该是短声明周期的变量
